---
title: 'The Recipe vs. The Cake: Understanding CSS Variable Inheritance'
description: Some random article
topics: [css]
date: 2026-01-20
---

I recently lost an entire afternoon because I had a flawed mental model of how CSS resolves its variables. It was one of those humbling moments where you think you understand how the web works, only to realize you have been walking past a trapdoor for years without noticing it.

I wanted to improve the maintainability of our CSS by creating a shared set of styles. The goal was simple. Define the shadow logic in one place, then let individual components tweak the elevation and color.

It worked perfectly until it didn't.

Here is the simplified setup:

<include>./initial.css</include>

I defined a shadow variable at the root level that depended on a secondary color variable `(--shadow-elevation-color){:css}`. I applied this to my components using a flexible declaration: `box-shadow: var(--ui-box-shadow, var(--shadow-elevation-raised)){:css}`. This pattern allows an element to use the default 'raised' shadow while leaving the door open for overrides via `--ui-box-shadow{:css}`. Swapping the shadow token worked flawlessly.

But when I tried to modify the ingredients, nothing happened. I defined the shadow color variable locally as red. The change was ignored. The shadow stayed stubbornly black.

I stared at the dev tools. The variable was right there. The cascade was working. The specificity was correct. But the browser acted like my local variable didn't exist.

I had walked into the Computed Value Trap.
