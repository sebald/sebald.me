---
title: 'The Recipe & the Cake: Understanding CSS Variable Inheritance'
description: Some random article
topics: [css]
date: 2026-01-20
---

I recently lost an entire afternoon because I had a flawed mental model of how CSS resolves its variables. It was one of those humbling moments where you think you understand how the web works, only to realize you have been walking past a trapdoor for years without noticing it.

I wanted to improve the maintainability of our design system. The goal was simple. Define the shadow logic in one place, then let individual components tweak the elevation and color.

It worked perfectly until it didn't.

Here is the simplified setup using Tailwind. I defined a shadow variable within the global `@theme{:css}` block (which essentially maps to `:root{:css}`) that depended on a secondary color variable (`--shadow-elevation-color{:css}`). I applied this to my components using a flexible declaration. This pattern allows an element to use the default 'raised' shadow while leaving the door open for overrides via `--ui-box-shadow{:css}`.

It looks logical. The configuration reads like it should work.

```css
@theme {
  --color-destructive: var(--color-red-500);

  /* The Trap:
    We define the shadows globally in the theme. The browser looks for --shadow-elevation-color.
    It's not defined yet. So it resolves the fallback (#000) immediately.
  */
  --shadow-elevation-raised:
    0 0.5px 1px oklch(from var(--shadow-elevation-color, #000) l c h / 1),
    0 1px 2px oklch(from var(--shadow-elevation-color, #000) l c h / 0.06);

  --shadow-elevation-overlay:
    0 1px 2px oklch(from var(--shadow-elevation-color, #000) l c h / 0.12),
    0 2px 4px oklch(from var(--shadow-elevation-color, #000) l c h / 0.8),
    0 4px 8px oklch(from var(--shadow-elevation-color, #000) l c h / 0.08);
}

@utility ui-card {
  @apply aspect-video rounded-xl border border-gray-300 bg-white px-24;
  @apply grid place-items-center;

  /* We expect the shadow to re-calculate when --shadow-elevation-color changes.
     The Reality: It uses the pre-baked #000 shadow from the @theme block.
  */
  @apply shadow-(--ui-box-shadow,var(--shadow-elevation-raised));
}

@utility ui-elevation-overlay {
  --ui-box-shadow: var(--shadow-elevation-overlay);
}

@utility ui-state-error {
  /* We try to inject the red color here */
  --shadow-elevation-color: var(--color-destructive);
  @apply border-destructive bg-destructive/5;
}
```

Swapping the shadow token (`--ui-box-shadow{:css}`) worked flawlessly. But when I tried to modify the ingredients, nothing happened. I defined the shadow color variable locally as red. The change was ignored. The shadow stayed stubbornly black.

I stared at the dev tools. The variable was right there. The cascade was working. The specificity was correct. But the browser acted like my local variable didn't exist.

What had happened?

## The Recipe vs. The Cake

To understand why this breaks, you have to look at how the browser actually reads the instructions. I used to think of CSS Custom Properties like dynamic closures in JavaScript. I assumed they were functions that waited to be called before they executed.

That is not quite accurate.

When you define a property dependent on other variables at the :root level (or in a global @theme block), the browser immediately resolves them. It does not wait to check the local variables available where the property is eventually used. Instead, it scans your formula, checks the root scope for ingredients, and locks in the final value right then and there.

In my case, the dependency (the shadow color) was undefined at the root level. The browser grabbed the fallback value (`#000`) and calculated the final result immediately. It turned what I thought was a dynamic formula into a static value.

You can think of this as a “recipe” and  a “cake”.

- **Specified Value (The Recipe):** The raw instruction: `oklch(from var(--color)...){:css}`.
- **Computed Value (The Cake):** The result: `rgb(0, 0, 0){:css}`.

In standard inheritance, we usually expect the child to inherit the recipe so it can bake its own cake using local ingredients. But because the formula was resolvable at the root (even via fallback), the browser baked the cake immediately.

It passed the pre-baked black cake down to my component. When my component declared "Hey, I have a red ingredient here," it didn't matter. The inheritance chain wasn't passing down a function anymore. It was passing down a static result.

## The Performance Trade-off

From the perspective of a developer, this behavior seems completely illogical. It feels like the machine is skipping steps and ignoring our intent. But if you look at it from the browser engine's perspective, it is a feature.

The browser is prioritizing performance over dynamic potential. It is using lexical scoping (resolving based on where it is defined) rather than dynamic scoping (resolving based on where it is used).

If the browser re-evaluated every single variable at every single level of the DOM "just in case" a dependency changed, rendering performance would tank. So it snapshots the computed value whenever it can.

The fix is surprisingly simple. You have to force the browser to treat the variable as a new instruction rather than an inherited value.

## The Fix: Moving the Scope

To make this work, you have to prevent the `:root{:css}` from baking the cake. We need to define the shadow formula in a place where it knows it might need to change, or ensure the dependency is always technically unresolved until it hits the component.

The solution is to move the definition from the global @theme block directly onto a `@utility{:css}` class.

By doing this, we change the browser's order of operations:

1. The browser encounters the `.ui-card{:css}` class on your element.
2. It sees the custom property definition for `--shadow-elevation-raised{:css}` inside that class (brought in via `@apply{:css}`).
3. Since the definition is local to the element, the browser pauses. It looks at the _element's_ current context to find any dependencies.
4. It finds your local `--shadow-elevation-color{:css}` (set by the error state) right there on the same element.
5. It calculates the shadow using the fresh ingredient.

We essentially stopped trying to broadcast the recipe from the global scope and instead handed the recipe directly to the specific component that needs to cook it. By moving the definition off the `@theme{:css}` (root) and into the `@utility{:css}`, we tell the browser "Do not assume this value is static." We force it to check the local scope for ingredients before baking the cake.

```css
/* The Fix */

@theme {
  --color-destructive: var(--color-red-500);
}

/* Moving definitions into @utility guarantees late binding.  
 The browser waits until it hits these specific classes to calculate the formula.  
*/
@utility ui-shadow-raised {
  --shadow-elevation-raised:
    0 0.5px 1px oklch(from var(--shadow-elevation-color, #000) l c h / 1),
    0 1px 2px oklch(from var(--shadow-elevation-color, #000) l c h / 0.06);
}

@utility ui-shadow-overlay {
  --shadow-elevation-overlay:
    0 1px 2px oklch(from var(--shadow-elevation-color, #000) l c h / 0.12),
    0 2px 4px oklch(from var(--shadow-elevation-color, #000) l c h / 0.8),
    0 4px 8px oklch(from var(--shadow-elevation-color, #000) l c h / 0.08);
}

@utility ui-card {
  @apply aspect-video rounded-xl border border-gray-300 bg-white px-24;
  @apply grid place-items-center;

  /* Apply the utility containing the formula */
  @apply ui-shadow-raised;

  /* How the shadow is applied does not change */
  @apply shadow-(--ui-box-shadow,var(--shadow-elevation-raised));
}

@utility ui-elevation-overlay {
  @apply ui-shadow-overlay;
  --ui-box-shadow: var(--shadow-elevation-overlay);
}

@utility ui-state-error {
  @apply border-destructive bg-destructive/5;

  /* Now this works because the recipe is evaluated in the component scope */
  --shadow-elevation-color: var(--color-destructive);
}
```

## The Sledgehammer Alternative

I haven't mentioned the universal `*{:css}` selector yet. While moving the definition from `:root{:css}` (or `@theme{:css}`) to `*{:css}` works, it carries a hidden performance tax.

It comes down to _when_ and _where_ the browser decides to "bake the cake."

When you define the variable on :root, the browser attempts to resolve the formula _once_, at the very top of the document. It asks if `--shadow-elevation-color{:css}` exists at the root. Since it doesn't, it uses the fallback (`#000{:css}`), calculates the final pixels, and passes that static result down to every child. When your component inherits it, it receives the "baked cake" (the black shadow) and never gets the chance to check its own local red variable.

On the other hand, if you define the variable on `*{:css}`, you are telling the browser to apply this definition to _every single element_ individually. When the browser hits your `.ui-card{:css}`, the `*{:css}` selector matches it, forcing a specific calculation for that element. It looks for ?`--shadow-elevation-color{:css}` on the card itself, finds your local red variable, and bakes the shadow fresh.

While `*{:css}` fixes the bug by forcing late binding everywhere, it is basically using a sledgehammer. It forces the browser to re-evaluate that variable for every single node in your DOM tree. If the formula is complex, this can be heavy.

That is why defining it specifically on the component class (e.g., `.ui-card{:css}`) is the sensible choice. It forces the fresh calculation only where you actually need it.

## Closing Thoughts

Global variables are for constants. Local variables are for logic.

That is the takeaway. You cannot fight the browser's optimization engine; you have to work around it. To ensure late binding actually happens, we need to follow these rules:

1. **Separate Primitives from Recipes:** The `:root{:css}` (or `@theme{:css}`) scope is for raw ingredients (colors, spacing), not cooking instructions.
2. **Match Lifecycles:** If Variable A depends on Variable B, they must be defined in the same scope. A global formula cannot depend on a component-level variable.
3. **Localize Logic:** The closer the logic is to the pixel, the safer it is. Define complex variables inside your component classes to force the browser to recalculate using local context.
